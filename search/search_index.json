{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"body {text-align: justify} Integrantes do Grupo: Guilherme Brito Vilas Boas (190108011) Silas Neres de Souza (200043536) Daniel Rocha Oliveira (190104821) Sistema Utilizado: Linux Ubuntu 22.04 Ambiente de Desenvolvimento: Visual Studio Code Linguagem: C Build Para a build desse projeto, \u00e9 necess\u00e1rio rodar o comando make project para que o arquivo execut\u00e1vel seja gerado. Execu\u00e7\u00e3o do Programa Para a execu\u00e7\u00e3o do programa, basta, ap\u00f3s a build , executar o comando ./project <IP SERVIDOR SNTP> . exemplo: ./project 129.6.15.28 Introdu\u00e7\u00e3o Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305 . Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados. Componentes Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio o desenvolvimento de componentes adicionais, como, por exemplo um Cliente Gen\u00e9rico UDP . Cliente UDP Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca de um cliente UDP gen\u00e9rico desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void * send_message ( const char * peer_ip, int peer_port, void * payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; // Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2 (1 + 1 tentativa), conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; // Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente SNTP espera receber uma resposta do servidor contendo informa\u00e7\u00f5es sobre o tempo. int timeout; // Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. } Retorno A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o retorna NULL. L\u00f3gica de Funcionamento 1. Configura\u00e7\u00e3o do Endere\u00e7o de Destino O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, & peer_addr.sin_addr) <= 0 ) { perror( \"Invalid IP address.\" ); return NULL; } 2. Cria\u00e7\u00e3o do Socket UDP A fun\u00e7\u00e3o segue tentando criar um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0 ); if (udp_socket < 0 ) { perror( \"Socket creation failure.\" ); return NULL; } 3. Envio da Mensagem O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . if (sendto(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, sizeof (peer_addr)) < 0 ) { perror( \"Sending message failure.\" ); close_socket(udp_socket); return NULL; } 4. Aguarda Resposta Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado na flag timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . int try = 1 ; int total_tries = flags.retries + 1 ; do { flags.received_message = false; printf( \"Sending Message \\n\\t Try: %d \\n\\t Total tries:%d. \\n \" , try, total_tries); if (sendto(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, sizeof (peer_addr)) < 0 ) { perror( \"Sending message failure.\" ); close_socket(udp_socket); return NULL; } if (flags.wait_for_answer) { int ret; fd_set readfds; struct timeval timeout; timeout.tv_sec = flags.timeout; timeout.tv_usec = 0 ; FD_ZERO( & readfds); FD_SET(udp_socket, & readfds); printf( \" \\t Esperando resposta do servidor... \\n \" ); ret = select(udp_socket + 1 , & readfds, NULL, NULL, & timeout); if (ret < 0 ) { perror( \"Error during select.\" ); close_socket(udp_socket); return NULL; } else if (ret == 0 ) { printf( \" \\t Otempo expirou e n\u00e3o houve reposta do servidor. \\n \" ); try ++ ; } else { flags.received_message = true; } } } while (try <= total_tries && ! flags.received_message); 5. Recebimento da Resposta Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado. if (flags.received_message) { socklen_t addr_len = sizeof (peer_addr); ssize_t received_bytes = recvfrom(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, & addr_len); if (received_bytes < 0 ) { perror( \"Error receiving message.\" ); close_socket(udp_socket); return NULL; } else if (received_bytes < ( ssize_t ) sizeof ( struct ntp_packet )) { fprintf(stderr, \"Incomplete SNTP packet received (%zd bytes). \\n \" , received_bytes); close_socket(udp_socket); return NULL; } } 6. Fechamento do Socket Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema. int close_socket ( int socket) { if (close(socket) < 0 ) { perror( \"Error closing socket.\" ); return EXIT_FAILURE; } return EXIT_SUCCESS; } Exemplo de uso da biblioteca UDP struct send_message_flags flags = {.wait_for_answer = true, .timeout = 20 , .retries = 1 }; struct ntp_packet ntp_packet; memset( & ntp_packet, 0 , sizeof (ntp_packet)); ntp_packet.li_vn_mode = 0x1B ; struct ntp_packet * response = ( struct ntp_packet * )send_message(server_ip, 123 , ( void * ) & ntp_packet, flags); Parseamento e Recebimento da Mensagem Ap\u00f3s o recebimento da mensagem enviada pelo servidor, a mensagem \u00e9 processada e parseada. O objetivo \u00e9 garantir que os dados retornados pelo servidor estejam no formato esperado do protocolo SNTP e, em caso de falha, tratar os erros adequadamente. 1. Recebendo a Resposta do Servidor A fun\u00e7\u00e3o utiliza recvfrom() para capturar os dados enviados pelo servidor. Antes de processar a mensagem, o tamanho dos dados recebidos \u00e9 validado para garantir conformidade com o tamanho m\u00ednimo esperado para um pacote SNTP. int received_bytes = recvfrom(udp_socket, buffer, sizeof (buffer), 0 , NULL, NULL); if (received_bytes < sizeof ( struct ntp_packet )) { fprintf(stderr, \"Pacote SNTP inv\u00e1lido ou incompleto recebido. \\n \" ); close(udp_socket); return NULL; } 2. Validando o Formato do Pacote O pacote recebido \u00e9 interpretado como uma estrutura ntp_packet . Os campos da estrutura s\u00e3o validados para verificar se os dados correspondem ao esperado: O campo li_vn_mode \u00e9 usado para verificar a vers\u00e3o do protocolo e o modo de opera\u00e7\u00e3o. Outros campos, como stratum e precision , s\u00e3o analisados para determinar se o servidor est\u00e1 sincronizado corretamente. struct ntp_packet * response = ( struct ntp_packet * )buffer; if ((response -> li_vn_mode & 0x07 ) != 4 ) { // Verifica se o modo \u00e9 Server (4) fprintf(stderr, \"Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). \\n \" ); close(udp_socket); return NULL; } 3. Extra\u00e7\u00e3o de Dados de Tempo A partir do pacote SNTP, os timestamps relevantes s\u00e3o extra\u00eddos: rxTm_s (Receive Timestamp): Indica o hor\u00e1rio em que o servidor recebeu a requisi\u00e7\u00e3o do cliente. txTm_s (Transmit Timestamp): Indica o hor\u00e1rio em que o servidor enviou a resposta. Os timestamps s\u00e3o convertidos para um formato leg\u00edvel (e.g., UNIX Epoch) para c\u00e1lculos adicionais: uint32_t server_time = ntohl(response -> txTm_s); // Converte para a ordem de bytes do host server_time -= 2208988800U ; // Ajusta para o Epoch UNIX (1970) printf( \"Hor\u00e1rio recebido do servidor: %u \\n \" , server_time); 4. Convers\u00e3o de Data e Hora em Portugu\u00eas Foi feita uma tradu\u00e7\u00e3o da data e hora para o portugu\u00eas, atrav\u00e9s do c\u00f3digo a seguir que converte a \"data/hora\" do formato struct tm para uma string com nomes de dias da semana e meses traduzidos para portugu\u00eas. struct tm * tm_info = localtime( & tx_time); const char * dias_da_semana_pt[] = { \"Dom\" , \"Seg\" , \"Ter\" , \"Qua\" , \"Qui\" , \"Sex\" , \"S\u00e1b\" }; const char * meses_pt[] = { \"Jan\" , \"Fev\" , \"Mar\" , \"Abr\" , \"Mai\" , \"Jun\" , \"Jul\" , \"Ago\" , \"Set\" , \"Out\" , \"Nov\" , \"Dez\" }; char dia_semana[ 4 ]; strftime(dia_semana, sizeof (dia_semana), \"%a\" , tm_info); for ( int i = 0 ; i < 7 ; i ++ ) { if (strcmp(dia_semana, \"Sun\" ) == 0 ) strcpy(dia_semana, dias_da_semana_pt[ 0 ]); // Outras compara\u00e7\u00f5es semelhantes... } 5. Tratamento de Erros Em caso de erro no parseamento ou valida\u00e7\u00e3o: Uma mensagem de erro \u00e9 registrada no log. O socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Exemplo de erro ao processar um campo inv\u00e1lido: if (response -> stratum == 0 || response -> stratum > 16 ) { fprintf(stderr, \"Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. \\n \" ); close(udp_socket); return NULL; } Comportamento em Caso de Falha Recebimento Incompleto: Se o tamanho dos dados recebidos for menor que o esperado, o socket \u00e9 fechado e uma mensagem de erro \u00e9 exibida. Pacote Inv\u00e1lido: Caso os campos do pacote n\u00e3o estejam no formato esperado, o cliente trata como erro e retorna NULL . Servidor N\u00e3o Sincronizado: Se o servidor indicar que n\u00e3o est\u00e1 sincronizado (e.g., Stratum 0), o cliente registra o problema e encerra a conex\u00e3o. Mensagens de Log Pacote SNTP inv\u00e1lido ou incompleto recebido. : Indica que os dados recebidos n\u00e3o t\u00eam o tamanho m\u00ednimo esperado para um pacote SNTP. Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). : Informa que o pacote n\u00e3o est\u00e1 no modo correto para respostas SNTP. Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. : Indica que o servidor est\u00e1 fora de sincroniza\u00e7\u00e3o ou que os campos do pacote est\u00e3o incorretos. Hor\u00e1rio recebido do servidor: : Exibe o hor\u00e1rio recebido do servidor em formato UNIX Epoch.","title":"Home"},{"location":"#build","text":"Para a build desse projeto, \u00e9 necess\u00e1rio rodar o comando make project para que o arquivo execut\u00e1vel seja gerado.","title":"Build"},{"location":"#execucao-do-programa","text":"Para a execu\u00e7\u00e3o do programa, basta, ap\u00f3s a build , executar o comando ./project <IP SERVIDOR SNTP> . exemplo: ./project 129.6.15.28","title":"Execu\u00e7\u00e3o do Programa"},{"location":"#introducao","text":"Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305 . Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados.","title":"Introdu\u00e7\u00e3o"},{"location":"#componentes","text":"Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio o desenvolvimento de componentes adicionais, como, por exemplo um Cliente Gen\u00e9rico UDP .","title":"Componentes"},{"location":"#cliente-udp","text":"Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca de um cliente UDP gen\u00e9rico desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void * send_message ( const char * peer_ip, int peer_port, void * payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; // Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2 (1 + 1 tentativa), conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; // Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente SNTP espera receber uma resposta do servidor contendo informa\u00e7\u00f5es sobre o tempo. int timeout; // Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. }","title":"Cliente UDP"},{"location":"#retorno","text":"A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o retorna NULL.","title":"Retorno"},{"location":"#logica-de-funcionamento","text":"","title":"L\u00f3gica de Funcionamento"},{"location":"#1-configuracao-do-endereco-de-destino","text":"O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, & peer_addr.sin_addr) <= 0 ) { perror( \"Invalid IP address.\" ); return NULL; }","title":"1. Configura\u00e7\u00e3o do Endere\u00e7o de Destino"},{"location":"#2-criacao-do-socket-udp","text":"A fun\u00e7\u00e3o segue tentando criar um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0 ); if (udp_socket < 0 ) { perror( \"Socket creation failure.\" ); return NULL; }","title":"2. Cria\u00e7\u00e3o do Socket UDP"},{"location":"#3-envio-da-mensagem","text":"O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . if (sendto(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, sizeof (peer_addr)) < 0 ) { perror( \"Sending message failure.\" ); close_socket(udp_socket); return NULL; }","title":"3. Envio da Mensagem"},{"location":"#4-aguarda-resposta","text":"Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado na flag timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . int try = 1 ; int total_tries = flags.retries + 1 ; do { flags.received_message = false; printf( \"Sending Message \\n\\t Try: %d \\n\\t Total tries:%d. \\n \" , try, total_tries); if (sendto(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, sizeof (peer_addr)) < 0 ) { perror( \"Sending message failure.\" ); close_socket(udp_socket); return NULL; } if (flags.wait_for_answer) { int ret; fd_set readfds; struct timeval timeout; timeout.tv_sec = flags.timeout; timeout.tv_usec = 0 ; FD_ZERO( & readfds); FD_SET(udp_socket, & readfds); printf( \" \\t Esperando resposta do servidor... \\n \" ); ret = select(udp_socket + 1 , & readfds, NULL, NULL, & timeout); if (ret < 0 ) { perror( \"Error during select.\" ); close_socket(udp_socket); return NULL; } else if (ret == 0 ) { printf( \" \\t Otempo expirou e n\u00e3o houve reposta do servidor. \\n \" ); try ++ ; } else { flags.received_message = true; } } } while (try <= total_tries && ! flags.received_message);","title":"4. Aguarda Resposta"},{"location":"#5-recebimento-da-resposta","text":"Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado. if (flags.received_message) { socklen_t addr_len = sizeof (peer_addr); ssize_t received_bytes = recvfrom(udp_socket, payload, sizeof ( struct ntp_packet ), 0 , ( struct sockaddr * ) & peer_addr, & addr_len); if (received_bytes < 0 ) { perror( \"Error receiving message.\" ); close_socket(udp_socket); return NULL; } else if (received_bytes < ( ssize_t ) sizeof ( struct ntp_packet )) { fprintf(stderr, \"Incomplete SNTP packet received (%zd bytes). \\n \" , received_bytes); close_socket(udp_socket); return NULL; } }","title":"5. Recebimento da Resposta"},{"location":"#6-fechamento-do-socket","text":"Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema. int close_socket ( int socket) { if (close(socket) < 0 ) { perror( \"Error closing socket.\" ); return EXIT_FAILURE; } return EXIT_SUCCESS; }","title":"6. Fechamento do Socket"},{"location":"#exemplo-de-uso-da-biblioteca-udp","text":"struct send_message_flags flags = {.wait_for_answer = true, .timeout = 20 , .retries = 1 }; struct ntp_packet ntp_packet; memset( & ntp_packet, 0 , sizeof (ntp_packet)); ntp_packet.li_vn_mode = 0x1B ; struct ntp_packet * response = ( struct ntp_packet * )send_message(server_ip, 123 , ( void * ) & ntp_packet, flags);","title":"Exemplo de uso da biblioteca UDP"},{"location":"#parseamento-e-recebimento-da-mensagem","text":"Ap\u00f3s o recebimento da mensagem enviada pelo servidor, a mensagem \u00e9 processada e parseada. O objetivo \u00e9 garantir que os dados retornados pelo servidor estejam no formato esperado do protocolo SNTP e, em caso de falha, tratar os erros adequadamente.","title":"Parseamento e Recebimento da Mensagem"},{"location":"#1-recebendo-a-resposta-do-servidor","text":"A fun\u00e7\u00e3o utiliza recvfrom() para capturar os dados enviados pelo servidor. Antes de processar a mensagem, o tamanho dos dados recebidos \u00e9 validado para garantir conformidade com o tamanho m\u00ednimo esperado para um pacote SNTP. int received_bytes = recvfrom(udp_socket, buffer, sizeof (buffer), 0 , NULL, NULL); if (received_bytes < sizeof ( struct ntp_packet )) { fprintf(stderr, \"Pacote SNTP inv\u00e1lido ou incompleto recebido. \\n \" ); close(udp_socket); return NULL; }","title":"1. Recebendo a Resposta do Servidor"},{"location":"#2-validando-o-formato-do-pacote","text":"O pacote recebido \u00e9 interpretado como uma estrutura ntp_packet . Os campos da estrutura s\u00e3o validados para verificar se os dados correspondem ao esperado: O campo li_vn_mode \u00e9 usado para verificar a vers\u00e3o do protocolo e o modo de opera\u00e7\u00e3o. Outros campos, como stratum e precision , s\u00e3o analisados para determinar se o servidor est\u00e1 sincronizado corretamente. struct ntp_packet * response = ( struct ntp_packet * )buffer; if ((response -> li_vn_mode & 0x07 ) != 4 ) { // Verifica se o modo \u00e9 Server (4) fprintf(stderr, \"Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). \\n \" ); close(udp_socket); return NULL; }","title":"2. Validando o Formato do Pacote"},{"location":"#3-extracao-de-dados-de-tempo","text":"A partir do pacote SNTP, os timestamps relevantes s\u00e3o extra\u00eddos: rxTm_s (Receive Timestamp): Indica o hor\u00e1rio em que o servidor recebeu a requisi\u00e7\u00e3o do cliente. txTm_s (Transmit Timestamp): Indica o hor\u00e1rio em que o servidor enviou a resposta. Os timestamps s\u00e3o convertidos para um formato leg\u00edvel (e.g., UNIX Epoch) para c\u00e1lculos adicionais: uint32_t server_time = ntohl(response -> txTm_s); // Converte para a ordem de bytes do host server_time -= 2208988800U ; // Ajusta para o Epoch UNIX (1970) printf( \"Hor\u00e1rio recebido do servidor: %u \\n \" , server_time);","title":"3. Extra\u00e7\u00e3o de Dados de Tempo"},{"location":"#4conversao-de-data-e-hora-em-portugues","text":"Foi feita uma tradu\u00e7\u00e3o da data e hora para o portugu\u00eas, atrav\u00e9s do c\u00f3digo a seguir que converte a \"data/hora\" do formato struct tm para uma string com nomes de dias da semana e meses traduzidos para portugu\u00eas. struct tm * tm_info = localtime( & tx_time); const char * dias_da_semana_pt[] = { \"Dom\" , \"Seg\" , \"Ter\" , \"Qua\" , \"Qui\" , \"Sex\" , \"S\u00e1b\" }; const char * meses_pt[] = { \"Jan\" , \"Fev\" , \"Mar\" , \"Abr\" , \"Mai\" , \"Jun\" , \"Jul\" , \"Ago\" , \"Set\" , \"Out\" , \"Nov\" , \"Dez\" }; char dia_semana[ 4 ]; strftime(dia_semana, sizeof (dia_semana), \"%a\" , tm_info); for ( int i = 0 ; i < 7 ; i ++ ) { if (strcmp(dia_semana, \"Sun\" ) == 0 ) strcpy(dia_semana, dias_da_semana_pt[ 0 ]); // Outras compara\u00e7\u00f5es semelhantes... }","title":"4.Convers\u00e3o de Data e Hora em Portugu\u00eas"},{"location":"#5-tratamento-de-erros","text":"Em caso de erro no parseamento ou valida\u00e7\u00e3o: Uma mensagem de erro \u00e9 registrada no log. O socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Exemplo de erro ao processar um campo inv\u00e1lido: if (response -> stratum == 0 || response -> stratum > 16 ) { fprintf(stderr, \"Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. \\n \" ); close(udp_socket); return NULL; }","title":"5. Tratamento de Erros"},{"location":"#comportamento-em-caso-de-falha","text":"Recebimento Incompleto: Se o tamanho dos dados recebidos for menor que o esperado, o socket \u00e9 fechado e uma mensagem de erro \u00e9 exibida. Pacote Inv\u00e1lido: Caso os campos do pacote n\u00e3o estejam no formato esperado, o cliente trata como erro e retorna NULL . Servidor N\u00e3o Sincronizado: Se o servidor indicar que n\u00e3o est\u00e1 sincronizado (e.g., Stratum 0), o cliente registra o problema e encerra a conex\u00e3o.","title":"Comportamento em Caso de Falha"},{"location":"#mensagens-de-log","text":"Pacote SNTP inv\u00e1lido ou incompleto recebido. : Indica que os dados recebidos n\u00e3o t\u00eam o tamanho m\u00ednimo esperado para um pacote SNTP. Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). : Informa que o pacote n\u00e3o est\u00e1 no modo correto para respostas SNTP. Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. : Indica que o servidor est\u00e1 fora de sincroniza\u00e7\u00e3o ou que os campos do pacote est\u00e3o incorretos. Hor\u00e1rio recebido do servidor: : Exibe o hor\u00e1rio recebido do servidor em formato UNIX Epoch.","title":"Mensagens de Log"}]}