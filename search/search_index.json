{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trabalho 01 Integrantes do Grupo: Guilherme Brito Vilas Boas (180108011) Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305. Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados. Componentes Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio desenvolver componentes adicionais, como, por exemplo: Cliente UDP Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca gen\u00e9rica desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; # Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2, conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; # Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente espera receber uma resposta contendo informa\u00e7\u00f5es sobre o tempo. int timeout; # Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. }; Retorno: A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna. L\u00f3gica de Funcionamento 1. Cria\u00e7\u00e3o do Socket UDP A fun\u00e7\u00e3o inicia criando um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); if (udp_socket < 0) { perror(\"Socket creation failure.\"); return NULL; } 2. Configura\u00e7\u00e3o do Endere\u00e7o de Destino O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, &peer_addr.sin_addr) <= 0) { perror(\"Invalid IP address.\"); return NULL; } int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); 3. Envio da Mensagem O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . O n\u00famero de tentativas de envio \u00e9 controlado pelo par\u00e2metro retries da estrutura flags . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . 4. Aguarda Resposta Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado em timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . 5. Recebimento da Resposta Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado. 6. Fechamento do Socket Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema. Comportamento em Caso de Falha: Erro no Envio : Se a fun\u00e7\u00e3o sendto() falhar, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Sem Resposta : Se a resposta n\u00e3o for recebida dentro do tempo limite, o c\u00f3digo tenta reenviar a mensagem at\u00e9 o n\u00famero m\u00e1ximo de tentativas. Erro ao Receber : Se houver erro ao receber a resposta ou se os dados recebidos n\u00e3o forem completos, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Mensagens de Log Sending Message : Indica que a mensagem est\u00e1 sendo enviada para o servidor. Esperando resposta do servidor... : Informa que o cliente est\u00e1 aguardando a resposta do servidor. O tempo expirou e n\u00e3o houve resposta do servidor. : Aparece caso o servidor n\u00e3o envie uma resposta dentro do tempo limite. Erro durante o select. : Aparece se ocorrer um erro na fun\u00e7\u00e3o select() ao aguardar pela resposta. Erro ao receber a mensagem. : Aparece se houver erro ao receber a resposta do servidor.","title":"Trabalho 01"},{"location":"#trabalho-01","text":"Integrantes do Grupo: Guilherme Brito Vilas Boas (180108011) Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305. Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados.","title":"Trabalho 01"},{"location":"#componentes","text":"Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio desenvolver componentes adicionais, como, por exemplo:","title":"Componentes"},{"location":"#cliente-udp","text":"Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca gen\u00e9rica desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; # Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2, conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; # Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente espera receber uma resposta contendo informa\u00e7\u00f5es sobre o tempo. int timeout; # Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. };","title":"Cliente UDP"},{"location":"#retorno","text":"A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna.","title":"Retorno:"},{"location":"#logica-de-funcionamento","text":"","title":"L\u00f3gica de Funcionamento"},{"location":"#1-criacao-do-socket-udp","text":"A fun\u00e7\u00e3o inicia criando um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); if (udp_socket < 0) { perror(\"Socket creation failure.\"); return NULL; }","title":"1. Cria\u00e7\u00e3o do Socket UDP"},{"location":"#2-configuracao-do-endereco-de-destino","text":"O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, &peer_addr.sin_addr) <= 0) { perror(\"Invalid IP address.\"); return NULL; } int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);","title":"2. Configura\u00e7\u00e3o do Endere\u00e7o de Destino"},{"location":"#3-envio-da-mensagem","text":"O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . O n\u00famero de tentativas de envio \u00e9 controlado pelo par\u00e2metro retries da estrutura flags . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL .","title":"3. Envio da Mensagem"},{"location":"#4-aguarda-resposta","text":"Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado em timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL .","title":"4. Aguarda Resposta"},{"location":"#5-recebimento-da-resposta","text":"Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado.","title":"5. Recebimento da Resposta"},{"location":"#6-fechamento-do-socket","text":"Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema.","title":"6. Fechamento do Socket"},{"location":"#comportamento-em-caso-de-falha","text":"Erro no Envio : Se a fun\u00e7\u00e3o sendto() falhar, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Sem Resposta : Se a resposta n\u00e3o for recebida dentro do tempo limite, o c\u00f3digo tenta reenviar a mensagem at\u00e9 o n\u00famero m\u00e1ximo de tentativas. Erro ao Receber : Se houver erro ao receber a resposta ou se os dados recebidos n\u00e3o forem completos, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL .","title":"Comportamento em Caso de Falha:"},{"location":"#mensagens-de-log","text":"Sending Message : Indica que a mensagem est\u00e1 sendo enviada para o servidor. Esperando resposta do servidor... : Informa que o cliente est\u00e1 aguardando a resposta do servidor. O tempo expirou e n\u00e3o houve resposta do servidor. : Aparece caso o servidor n\u00e3o envie uma resposta dentro do tempo limite. Erro durante o select. : Aparece se ocorrer um erro na fun\u00e7\u00e3o select() ao aguardar pela resposta. Erro ao receber a mensagem. : Aparece se houver erro ao receber a resposta do servidor.","title":"Mensagens de Log"}]}