{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Trabalho 01 Integrantes do Grupo: Silas Neres de Souza (200043536) Guilherme Brito Vilas Boas (180108011) Daniel Rocha Oliveira (190104821) O trabalho foi constru\u00eddo na linguagem C para rodar o projeto utilize o make run Este trabalho consiste na cria\u00e7\u00e3o de um Cliente para o protocolo SNTP. O protocolo SNTP \u00e9 um protocolo derivado do protocolo NTP (especificado na RFC-1305) e ambos s\u00e3o usados para manter os rel\u00f3gios de dispositivos sincronizados. Componentes Para a concep\u00e7\u00e3o desse trabalho, foi necess\u00e1rio implementar componentes adicionais, como por exemplo: Cliente UDP Para o cliente UDP, foi criado uma fun\u00e7\u00e3o principal chamada send_message . A fun\u00e7\u00e3o send_message \u00e9 respons\u00e1vel por criar e enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o IP e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do envio da mensagem: struct send_message_flags { int retries; // Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2, conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; // Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente espera receber uma resposta contendo informa\u00e7\u00f5es sobre o tempo. int timeout; // Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. }; Retorno: A fun\u00e7\u00e3o retorna um ponteiro void* , que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true ). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna. Parseamento e Recebimento da Mensagem Ap\u00f3s o recebimento da mensagem enviada pelo servidor, o c\u00f3digo implementa uma l\u00f3gica robusta para parsear e processar a resposta. O objetivo \u00e9 garantir que os dados retornados pelo servidor estejam no formato esperado do protocolo SNTP e, em caso de falha, tratar os erros adequadamente. 1. Recebendo a Resposta do Servidor A fun\u00e7\u00e3o utiliza recvfrom() para capturar os dados enviados pelo servidor. Antes de processar a mensagem, o tamanho dos dados recebidos \u00e9 validado para garantir conformidade com o tamanho m\u00ednimo esperado para um pacote SNTP. int received_bytes = recvfrom(udp_socket, buffer, sizeof(buffer), 0, NULL, NULL); if (received_bytes < sizeof(struct ntp_packet)) { fprintf(stderr, \"Pacote SNTP inv\u00e1lido ou incompleto recebido.\\n\"); close(udp_socket); return NULL; } 2. Validando o Formato do Pacote O pacote recebido \u00e9 interpretado como uma estrutura ntp_packet . Os campos da estrutura s\u00e3o validados para verificar se os dados correspondem ao esperado: O campo li_vn_mode \u00e9 usado para verificar a vers\u00e3o do protocolo e o modo de opera\u00e7\u00e3o. Outros campos, como stratum e precision , s\u00e3o analisados para determinar se o servidor est\u00e1 sincronizado corretamente. struct ntp_packet *response = (struct ntp_packet *)buffer; if ((response->li_vn_mode & 0x07) != 4) { // Verifica se o modo \u00e9 Server (4) fprintf(stderr, \"Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server).\\n\"); close(udp_socket); return NULL; } 3. Extra\u00e7\u00e3o de Dados de Tempo A partir do pacote SNTP, os timestamps relevantes s\u00e3o extra\u00eddos: rxTm_s (Receive Timestamp): Indica o hor\u00e1rio em que o servidor recebeu a requisi\u00e7\u00e3o do cliente. txTm_s (Transmit Timestamp): Indica o hor\u00e1rio em que o servidor enviou a resposta. Os timestamps s\u00e3o convertidos para um formato leg\u00edvel (e.g., UNIX Epoch) para c\u00e1lculos adicionais: uint32_t server_time = ntohl(response->txTm_s); // Converte para a ordem de bytes do host server_time -= 2208988800U; // Ajusta para o Epoch UNIX (1970) printf(\"Hor\u00e1rio recebido do servidor: %u\\n\", server_time); 4. Convers\u00e3o de Data e Hora em Portugu\u00eas Foi feita uma tradu\u00e7\u00e3o da data e hora para o portugu\u00eas, atrav\u00e9s do c\u00f3digo a seguir que converte a \"data/hora\" do formato struct tm para uma string com nomes de dias da semana e meses traduzidos para portugu\u00eas. struct tm *tm_info = localtime(&tx_time); const char *dias_da_semana_pt[] = {\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"S\u00e1b\"}; const char *meses_pt[] = {\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"}; char dia_semana[4]; strftime(dia_semana, sizeof(dia_semana), \"%a\", tm_info); for (int i = 0; i < 7; i++) { if (strcmp(dia_semana, \"Sun\") == 0) strcpy(dia_semana, dias_da_semana_pt[0]); // Outras compara\u00e7\u00f5es semelhantes... } 5. Tratamento de Erros Em caso de erro no parseamento ou valida\u00e7\u00e3o: Uma mensagem de erro \u00e9 registrada no log. O socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Exemplo de erro ao processar um campo inv\u00e1lido: if (response->stratum == 0 || response->stratum > 16) { fprintf(stderr, \"Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida.\\n\"); close(udp_socket); return NULL; } Comportamento em Caso de Falha Recebimento Incompleto: Se o tamanho dos dados recebidos for menor que o esperado, o socket \u00e9 fechado e uma mensagem de erro \u00e9 exibida. Pacote Inv\u00e1lido: Caso os campos do pacote n\u00e3o estejam no formato esperado, o cliente trata como erro e retorna NULL . Servidor N\u00e3o Sincronizado: Se o servidor indicar que n\u00e3o est\u00e1 sincronizado (e.g., Stratum 0), o cliente registra o problema e encerra a conex\u00e3o. Mensagens de Log Pacote SNTP inv\u00e1lido ou incompleto recebido. : Indica que os dados recebidos n\u00e3o t\u00eam o tamanho m\u00ednimo esperado para um pacote SNTP. Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). : Informa que o pacote n\u00e3o est\u00e1 no modo correto para respostas SNTP. Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. : Indica que o servidor est\u00e1 fora de sincroniza\u00e7\u00e3o ou que os campos do pacote est\u00e3o incorretos. Hor\u00e1rio recebido do servidor: : Exibe o hor\u00e1rio recebido do servidor em formato UNIX Epoch.","title":"Trabalho 01"},{"location":"#trabalho-01","text":"Integrantes do Grupo: Silas Neres de Souza (200043536) Guilherme Brito Vilas Boas (180108011) Daniel Rocha Oliveira (190104821) O trabalho foi constru\u00eddo na linguagem C para rodar o projeto utilize o make run Este trabalho consiste na cria\u00e7\u00e3o de um Cliente para o protocolo SNTP. O protocolo SNTP \u00e9 um protocolo derivado do protocolo NTP (especificado na RFC-1305) e ambos s\u00e3o usados para manter os rel\u00f3gios de dispositivos sincronizados.","title":"Trabalho 01"},{"location":"#componentes","text":"Para a concep\u00e7\u00e3o desse trabalho, foi necess\u00e1rio implementar componentes adicionais, como por exemplo:","title":"Componentes"},{"location":"#cliente-udp","text":"Para o cliente UDP, foi criado uma fun\u00e7\u00e3o principal chamada send_message . A fun\u00e7\u00e3o send_message \u00e9 respons\u00e1vel por criar e enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o IP e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do envio da mensagem: struct send_message_flags { int retries; // Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2, conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; // Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente espera receber uma resposta contendo informa\u00e7\u00f5es sobre o tempo. int timeout; // Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. };","title":"Cliente UDP"},{"location":"#retorno","text":"A fun\u00e7\u00e3o retorna um ponteiro void* , que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true ). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna.","title":"Retorno:"},{"location":"#parseamento-e-recebimento-da-mensagem","text":"Ap\u00f3s o recebimento da mensagem enviada pelo servidor, o c\u00f3digo implementa uma l\u00f3gica robusta para parsear e processar a resposta. O objetivo \u00e9 garantir que os dados retornados pelo servidor estejam no formato esperado do protocolo SNTP e, em caso de falha, tratar os erros adequadamente.","title":"Parseamento e Recebimento da Mensagem"},{"location":"#1-recebendo-a-resposta-do-servidor","text":"A fun\u00e7\u00e3o utiliza recvfrom() para capturar os dados enviados pelo servidor. Antes de processar a mensagem, o tamanho dos dados recebidos \u00e9 validado para garantir conformidade com o tamanho m\u00ednimo esperado para um pacote SNTP. int received_bytes = recvfrom(udp_socket, buffer, sizeof(buffer), 0, NULL, NULL); if (received_bytes < sizeof(struct ntp_packet)) { fprintf(stderr, \"Pacote SNTP inv\u00e1lido ou incompleto recebido.\\n\"); close(udp_socket); return NULL; }","title":"1. Recebendo a Resposta do Servidor"},{"location":"#2-validando-o-formato-do-pacote","text":"O pacote recebido \u00e9 interpretado como uma estrutura ntp_packet . Os campos da estrutura s\u00e3o validados para verificar se os dados correspondem ao esperado: O campo li_vn_mode \u00e9 usado para verificar a vers\u00e3o do protocolo e o modo de opera\u00e7\u00e3o. Outros campos, como stratum e precision , s\u00e3o analisados para determinar se o servidor est\u00e1 sincronizado corretamente. struct ntp_packet *response = (struct ntp_packet *)buffer; if ((response->li_vn_mode & 0x07) != 4) { // Verifica se o modo \u00e9 Server (4) fprintf(stderr, \"Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server).\\n\"); close(udp_socket); return NULL; }","title":"2. Validando o Formato do Pacote"},{"location":"#3-extracao-de-dados-de-tempo","text":"A partir do pacote SNTP, os timestamps relevantes s\u00e3o extra\u00eddos: rxTm_s (Receive Timestamp): Indica o hor\u00e1rio em que o servidor recebeu a requisi\u00e7\u00e3o do cliente. txTm_s (Transmit Timestamp): Indica o hor\u00e1rio em que o servidor enviou a resposta. Os timestamps s\u00e3o convertidos para um formato leg\u00edvel (e.g., UNIX Epoch) para c\u00e1lculos adicionais: uint32_t server_time = ntohl(response->txTm_s); // Converte para a ordem de bytes do host server_time -= 2208988800U; // Ajusta para o Epoch UNIX (1970) printf(\"Hor\u00e1rio recebido do servidor: %u\\n\", server_time);","title":"3. Extra\u00e7\u00e3o de Dados de Tempo"},{"location":"#4conversao-de-data-e-hora-em-portugues","text":"Foi feita uma tradu\u00e7\u00e3o da data e hora para o portugu\u00eas, atrav\u00e9s do c\u00f3digo a seguir que converte a \"data/hora\" do formato struct tm para uma string com nomes de dias da semana e meses traduzidos para portugu\u00eas. struct tm *tm_info = localtime(&tx_time); const char *dias_da_semana_pt[] = {\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"S\u00e1b\"}; const char *meses_pt[] = {\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"}; char dia_semana[4]; strftime(dia_semana, sizeof(dia_semana), \"%a\", tm_info); for (int i = 0; i < 7; i++) { if (strcmp(dia_semana, \"Sun\") == 0) strcpy(dia_semana, dias_da_semana_pt[0]); // Outras compara\u00e7\u00f5es semelhantes... }","title":"4.Convers\u00e3o de Data e Hora em Portugu\u00eas"},{"location":"#5-tratamento-de-erros","text":"Em caso de erro no parseamento ou valida\u00e7\u00e3o: Uma mensagem de erro \u00e9 registrada no log. O socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . Exemplo de erro ao processar um campo inv\u00e1lido: if (response->stratum == 0 || response->stratum > 16) { fprintf(stderr, \"Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida.\\n\"); close(udp_socket); return NULL; }","title":"5. Tratamento de Erros"},{"location":"#comportamento-em-caso-de-falha","text":"Recebimento Incompleto: Se o tamanho dos dados recebidos for menor que o esperado, o socket \u00e9 fechado e uma mensagem de erro \u00e9 exibida. Pacote Inv\u00e1lido: Caso os campos do pacote n\u00e3o estejam no formato esperado, o cliente trata como erro e retorna NULL . Servidor N\u00e3o Sincronizado: Se o servidor indicar que n\u00e3o est\u00e1 sincronizado (e.g., Stratum 0), o cliente registra o problema e encerra a conex\u00e3o.","title":"Comportamento em Caso de Falha"},{"location":"#mensagens-de-log","text":"Pacote SNTP inv\u00e1lido ou incompleto recebido. : Indica que os dados recebidos n\u00e3o t\u00eam o tamanho m\u00ednimo esperado para um pacote SNTP. Resposta recebida n\u00e3o est\u00e1 no modo esperado (Server). : Informa que o pacote n\u00e3o est\u00e1 no modo correto para respostas SNTP. Servidor n\u00e3o sincronizado ou resposta inv\u00e1lida. : Indica que o servidor est\u00e1 fora de sincroniza\u00e7\u00e3o ou que os campos do pacote est\u00e3o incorretos. Hor\u00e1rio recebido do servidor: : Exibe o hor\u00e1rio recebido do servidor em formato UNIX Epoch.","title":"Mensagens de Log"}]}