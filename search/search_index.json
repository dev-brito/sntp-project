{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"body {text-align: justify} Integrantes do Grupo: Guilherme Brito Vilas Boas (190108011) Sistema Utilizado: Linux Ubuntu 22.04 Ambiente de Desenvolvimento: Visual Studio Code Build Para a build desse projeto, \u00e9 necess\u00e1rio rodar o comando make project para que o arquivo execut\u00e1vel seja gerado. Execu\u00e7\u00e3o do Programa Para a execu\u00e7\u00e3o do programa, basta ap\u00f3s a build , executar o comando ./project <IP SERVIDOR SNTP> . exemplo: ./project 129.6.15.28 Introdu\u00e7\u00e3o Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305 . Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados. Componentes Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio o desenvolvimento de componentes adicionais, como, por exemplo um Cliente Gen\u00e9rico UDP . Cliente B\u00e1sico UDP Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca de um cliente UDP gen\u00e9rico desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; # Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2 (1 + 1 tentativa), conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; # Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente SNTP espera receber uma resposta do servidor contendo informa\u00e7\u00f5es sobre o tempo. int timeout; # Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. }; Retorno A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna. L\u00f3gica de Funcionamento 1. Configura\u00e7\u00e3o do Endere\u00e7o de Destino O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, &peer_addr.sin_addr) <= 0) { perror(\"Invalid IP address.\"); return NULL; } int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); 2. Cria\u00e7\u00e3o do Socket UDP A fun\u00e7\u00e3o segue tentando criar um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); if (udp_socket < 0) { perror(\"Socket creation failure.\"); return NULL; } 3. Envio da Mensagem O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . if (sendto(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, sizeof(peer_addr)) < 0) { perror(\"Sending message failure.\"); close_socket(udp_socket); return NULL; } 4. Aguarda Resposta Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado na flag timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . int try = 1; int total_tries = flags.retries + 1; do { flags.received_message = false; printf(\"Sending Message\\n\\tTry: %d\\n\\tTotal tries:%d.\\n\", try, total_tries); if (sendto(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, sizeof(peer_addr)) < 0) { perror(\"Sending message failure.\"); close_socket(udp_socket); return NULL; } if (flags.wait_for_answer) { int ret; fd_set readfds; struct timeval timeout; timeout.tv_sec = flags.timeout; timeout.tv_usec = 0; FD_ZERO(&readfds); FD_SET(udp_socket, &readfds); printf(\"\\tEsperando resposta do servidor...\\n\"); ret = select(udp_socket + 1, &readfds, NULL, NULL, &timeout); if (ret < 0) { perror(\"Error during select.\"); close_socket(udp_socket); return NULL; } else if (ret == 0) { printf(\"\\tOtempo expirou e n\u00e3o houve reposta do servidor.\\n\"); try++; } else { flags.received_message = true; } } } while (try <= total_tries && !flags.received_message); 5. Recebimento da Resposta Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado. if (flags.received_message) { socklen_t addr_len = sizeof(peer_addr); ssize_t received_bytes = recvfrom(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, &addr_len); if (received_bytes < 0) { perror(\"Error receiving message.\"); close_socket(udp_socket); return NULL; } else if (received_bytes < (ssize_t)sizeof(struct ntp_packet)) { fprintf(stderr, \"Incomplete SNTP packet received (%zd bytes).\\n\", received_bytes); close_socket(udp_socket); return NULL; } } 6. Fechamento do Socket Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema. int close_socket(int socket) { if (close(socket) < 0) { perror(\"Error closing socket.\"); return EXIT_FAILURE; } return EXIT_SUCCESS; } Exemplo de Uso struct send_message_flags flags = {.wait_for_answer = true, .timeout = 20, .retries = 1}; struct ntp_packet ntp_packet; memset(&ntp_packet, 0, sizeof(ntp_packet)); ntp_packet.li_vn_mode = 0x1B; struct ntp_packet *response = (struct ntp_packet *)send_message(server_ip, 123, (void *)&ntp_packet, flags);","title":"Home"},{"location":"#build","text":"Para a build desse projeto, \u00e9 necess\u00e1rio rodar o comando make project para que o arquivo execut\u00e1vel seja gerado.","title":"Build"},{"location":"#execucao-do-programa","text":"Para a execu\u00e7\u00e3o do programa, basta ap\u00f3s a build , executar o comando ./project <IP SERVIDOR SNTP> . exemplo: ./project 129.6.15.28","title":"Execu\u00e7\u00e3o do Programa"},{"location":"#introducao","text":"Este trabalho tem como objetivo a cria\u00e7\u00e3o de um cliente para o protocolo SNTP. O SNTP (Simple Network Time Protocol) \u00e9 um protocolo derivado do NTP (Network Time Protocol), especificado pela RFC-1305 . Ambos os protocolos s\u00e3o utilizados para manter os rel\u00f3gios dos dispositivos sincronizados.","title":"Introdu\u00e7\u00e3o"},{"location":"#componentes","text":"Para a realiza\u00e7\u00e3o deste trabalho, foi necess\u00e1rio o desenvolvimento de componentes adicionais, como, por exemplo um Cliente Gen\u00e9rico UDP .","title":"Componentes"},{"location":"#cliente-basico-udp","text":"Neste t\u00f3pico, ser\u00e1 apresentada a descri\u00e7\u00e3o da pequena biblioteca de um cliente UDP gen\u00e9rico desenvolvida pelo grupo para enviar mensagens via protocolo UDP para um servidor. A fun\u00e7\u00e3o principal send_message \u00e9 respons\u00e1vel por enviar uma mensagem via protocolo UDP para o servidor especificado, al\u00e9m de gerenciar a espera pela resposta. Ela pode ser configurada com diferentes par\u00e2metros para ajustar o comportamento do envio e da espera pela resposta, como n\u00famero de tentativas e tempo de espera. void *send_message(const char *peer_ip, int peer_port, void *payload, struct send_message_flags flags); Essa fun\u00e7\u00e3o recebe por par\u00e2metro o ip e porta de envio do pacote UDP ( peer_ip e peer_port ), o pacote que ser\u00e1 enviado ( payload ) e um par\u00e2metro adicional de algumas flags poss\u00edveis para configura\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o: struct send_message_flags { int retries; # Define o n\u00famero de tentativas que o cliente deve realizar caso o envio da mensagem ou o recebimento da resposta falhe. O valor padr\u00e3o \u00e9 2 (1 + 1 tentativa), conforme especificado no relat\u00f3rio do Trabalho. bool wait_for_answer; # Indica se o cliente deve aguardar uma resposta ap\u00f3s enviar o pacote UDP. Para o cen\u00e1rio deste trabalho, este valor deve ser configurado como true, uma vez que o cliente SNTP espera receber uma resposta do servidor contendo informa\u00e7\u00f5es sobre o tempo. int timeout; # Define o tempo m\u00e1ximo (em segundos) que o cliente deve aguardar pela resposta do servidor antes de abortar a opera\u00e7\u00e3o. O valor padr\u00e3o \u00e9 configurado para 20 segundos, conforme especificado no relat\u00f3rio do Trabalho. };","title":"Cliente B\u00e1sico UDP"},{"location":"#retorno","text":"A fun\u00e7\u00e3o retorna um ponteiro void*, que pode ser utilizado para acessar a resposta do servidor (se wait_for_answer for true). Caso n\u00e3o haja resposta ou o tempo de espera seja excedido, a fun\u00e7\u00e3o pode retornar NULL ou um valor indicativo de falha, dependendo da implementa\u00e7\u00e3o interna.","title":"Retorno"},{"location":"#logica-de-funcionamento","text":"","title":"L\u00f3gica de Funcionamento"},{"location":"#1-configuracao-do-endereco-de-destino","text":"O endere\u00e7o IP e a porta do servidor de destino s\u00e3o configurados na estrutura sockaddr_in . O IP \u00e9 convertido de formato string para bin\u00e1rio usando a fun\u00e7\u00e3o inet_aton() . A porta de destino \u00e9 configurada com a fun\u00e7\u00e3o htons() para garantir que o valor seja interpretado corretamente pelo protocolo de rede. Caso o IP fornecido seja inv\u00e1lido, a fun\u00e7\u00e3o exibe uma mensagem de erro e retorna NULL . struct sockaddr_in peer_addr = {.sin_family = AF_INET, .sin_port = htons(peer_port)}; if (inet_aton(peer_ip, &peer_addr.sin_addr) <= 0) { perror(\"Invalid IP address.\"); return NULL; } int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);","title":"1. Configura\u00e7\u00e3o do Endere\u00e7o de Destino"},{"location":"#2-criacao-do-socket-udp","text":"A fun\u00e7\u00e3o segue tentando criar um socket UDP com a chamada \u00e0 fun\u00e7\u00e3o socket() . Se a cria\u00e7\u00e3o do socket falhar, uma mensagem de erro \u00e9 exibida, e a fun\u00e7\u00e3o retorna NULL . int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); if (udp_socket < 0) { perror(\"Socket creation failure.\"); return NULL; }","title":"2. Cria\u00e7\u00e3o do Socket UDP"},{"location":"#3-envio-da-mensagem","text":"O c\u00f3digo tenta enviar o pacote de dados (payload) para o servidor utilizando a fun\u00e7\u00e3o sendto() . Caso o envio falhe, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . if (sendto(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, sizeof(peer_addr)) < 0) { perror(\"Sending message failure.\"); close_socket(udp_socket); return NULL; }","title":"3. Envio da Mensagem"},{"location":"#4-aguarda-resposta","text":"Se a flag wait_for_answer for configurada como true , a fun\u00e7\u00e3o aguarda a resposta do servidor. A fun\u00e7\u00e3o utiliza a chamada select() para aguardar por uma resposta dentro do per\u00edodo de tempo configurado na flag timeout . A fun\u00e7\u00e3o verifica se o servidor respondeu dentro do tempo limite. Caso o tempo expire sem resposta, o c\u00f3digo tenta reenviar a mensagem at\u00e9 atingir o n\u00famero m\u00e1ximo de tentativas configurado. Se select() retornar um erro, o socket \u00e9 fechado e a fun\u00e7\u00e3o retorna NULL . int try = 1; int total_tries = flags.retries + 1; do { flags.received_message = false; printf(\"Sending Message\\n\\tTry: %d\\n\\tTotal tries:%d.\\n\", try, total_tries); if (sendto(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, sizeof(peer_addr)) < 0) { perror(\"Sending message failure.\"); close_socket(udp_socket); return NULL; } if (flags.wait_for_answer) { int ret; fd_set readfds; struct timeval timeout; timeout.tv_sec = flags.timeout; timeout.tv_usec = 0; FD_ZERO(&readfds); FD_SET(udp_socket, &readfds); printf(\"\\tEsperando resposta do servidor...\\n\"); ret = select(udp_socket + 1, &readfds, NULL, NULL, &timeout); if (ret < 0) { perror(\"Error during select.\"); close_socket(udp_socket); return NULL; } else if (ret == 0) { printf(\"\\tOtempo expirou e n\u00e3o houve reposta do servidor.\\n\"); try++; } else { flags.received_message = true; } } } while (try <= total_tries && !flags.received_message);","title":"4. Aguarda Resposta"},{"location":"#5-recebimento-da-resposta","text":"Quando uma resposta do servidor \u00e9 recebida, o c\u00f3digo a processa com a fun\u00e7\u00e3o recvfrom() . O tamanho dos dados recebidos \u00e9 comparado com o tamanho esperado de um pacote SNTP. Se a quantidade de dados recebidos for menor do que o esperado, um erro \u00e9 gerado e o socket \u00e9 fechado. if (flags.received_message) { socklen_t addr_len = sizeof(peer_addr); ssize_t received_bytes = recvfrom(udp_socket, payload, sizeof(struct ntp_packet), 0, (struct sockaddr *)&peer_addr, &addr_len); if (received_bytes < 0) { perror(\"Error receiving message.\"); close_socket(udp_socket); return NULL; } else if (received_bytes < (ssize_t)sizeof(struct ntp_packet)) { fprintf(stderr, \"Incomplete SNTP packet received (%zd bytes).\\n\", received_bytes); close_socket(udp_socket); return NULL; } }","title":"5. Recebimento da Resposta"},{"location":"#6-fechamento-do-socket","text":"Ap\u00f3s o envio ou recebimento da mensagem, o socket \u00e9 fechado com a fun\u00e7\u00e3o close_socket() . A fun\u00e7\u00e3o close_socket() garante que o socket seja fechado corretamente, liberando os recursos do sistema. int close_socket(int socket) { if (close(socket) < 0) { perror(\"Error closing socket.\"); return EXIT_FAILURE; } return EXIT_SUCCESS; }","title":"6. Fechamento do Socket"},{"location":"#exemplo-de-uso","text":"struct send_message_flags flags = {.wait_for_answer = true, .timeout = 20, .retries = 1}; struct ntp_packet ntp_packet; memset(&ntp_packet, 0, sizeof(ntp_packet)); ntp_packet.li_vn_mode = 0x1B; struct ntp_packet *response = (struct ntp_packet *)send_message(server_ip, 123, (void *)&ntp_packet, flags);","title":"Exemplo de Uso"}]}